/*
 * The Clear BSD License
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted (subject to the limitations in the disclaimer below) provided
 *  that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bootloader_common.h"
#include "fsl_device_registers.h"
#include "security/cbc_mac.h"
#include "security/aes_security.h"
#include <string.h>

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define LED1_OFFSET 6
#define LED2_OFFSET 7
#define LED3_OFFSET 8
#define LED4_OFFSET 9

#define LED1 (1) // green
#define LED2 (2) // yellow
#define LED3 (4) // orange
#define LED4 (8) // blue

#define LED1_GPIO (PTE)
#define LED2_GPIO (PTE)
#define LED3_GPIO (PTE)

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/

// This is the header portion of an encrypted sb file (this particular one is the header of the encrypted
// K64 tower led demo ) generated using elftosb
static uint8_t s_header[] = {
    0x64, 0xAA, 0x1D, 0x66, 0x61, 0xFD, 0x0D, 0x4B, 0x7D, 0xC5, 0xE8, 0x50, 0xF8, 0x0B, 0x39, 0x1F, 0x96, 0x03, 0xEB,
    0x7A, 0x53, 0x54, 0x4D, 0x50, 0x01, 0x01, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x00, 0x51, 0xFD, 0x73, 0x67, 0x74, 0x6C, 0xC0,
    0x5B, 0x96, 0x83, 0x06, 0x9F, 0x01, 0x00, 0x09, 0x99, 0x00, 0x00, 0x09, 0x99, 0x00, 0x00, 0x09, 0x99, 0x00, 0x00,
    0x09, 0x99, 0x00, 0x00, 0x09, 0x99, 0x00, 0x00, 0x09, 0x99, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x6D, 0x72, 0xB7, 0x35,
    0xEF, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xCB, 0x12,
    0x61, 0xF1, 0x85, 0x60, 0xCD, 0xD6, 0xDB, 0xB0, 0x4E, 0x5C, 0x46, 0x4C, 0x37, 0x3E,            // MAC
    0xAF, 0x9B, 0x66, 0x57, 0x69, 0xC8, 0x28, 0x36, 0x9F, 0xC8, 0xD7, 0x84, 0xAE, 0x77, 0xAE, 0xB6 // DEK
};

// This is a portion of the first section of the LED demo encrypted sb file for k64 tower
static uint8_t s_encryptedSectionData[] = {
    0x58, 0x79, 0xC7, 0x3D, 0x50, 0xB0, 0x44, 0x97, 0x2C, 0x90, 0x02, 0x58, 0x8B, 0x62, 0x5D, 0x24, // Boot tag
    0x4B, 0x0F, 0xC8, 0x24, 0x45, 0x03, 0xF0, 0xFB, 0x3D, 0xB0, 0xB9, 0x6B, 0x53, 0xAF, 0x2F, 0xA7, // Section Data...
    0x00, 0xC3, 0xAB, 0xEF, 0xC7, 0x20, 0x4B, 0xFF, 0xD9, 0x45, 0x74, 0x1E, 0x31, 0x45, 0x06, 0x68, 0xF2, 0xE6, 0xF0,
    0xB6, 0x72, 0xED, 0x90, 0xBC, 0x3E, 0x2A, 0xCA, 0x02, 0x0A, 0x11, 0x25, 0xCE, 0xC2, 0xE6, 0x63, 0x75, 0xD6, 0xCE,
    0xC0, 0x26, 0x9E, 0x91, 0xFE, 0x3A, 0x12, 0x41, 0xCA, 0xF1, 0x32, 0x77, 0x06, 0x02, 0xF6, 0x30, 0x5D, 0x1B, 0xEF,
    0x74, 0x25, 0x70, 0xFA, 0x69, 0x32, 0xB4, 0x46, 0xB6, 0x90, 0xEE, 0xB8, 0x5B, 0x87, 0xF4, 0x59, 0x6A, 0x81, 0xE0,
    0x8A, 0xEB, 0x99, 0xCB, 0xC3, 0x30, 0x87, 0xFD, 0x9E, 0x25, 0x62, 0xF9, 0xF5, 0x9E, 0xAA, 0xE1, 0x91, 0xE3, 0x0A,
    0xD2, 0xAD, 0x9C, 0x31, 0x49, 0xB2, 0xC0, 0xB4, 0x17, 0xCD, 0x44, 0xBE, 0x07, 0x26, 0x16, 0xE9, 0x72, 0xD1, 0x77,
    0x86, 0x48, 0x2A, 0x7A, 0xE0, 0xF3, 0xCB, 0x09, 0x5A, 0x35, 0xA7, 0x36, 0x5A, 0xD6, 0xAE, 0x07, 0x4C, 0xF3, 0x7F,
    0xFC, 0x35, 0xE0, 0x26, 0xC1, 0x66, 0xA7, 0xE7, 0xF8, 0xEC, 0x9D, 0x00, 0x56, 0xCB, 0x0A, 0x42, 0xE0, 0xBB, 0xE2,
    0x51, 0x07, 0xA3, 0x74, 0x07, 0x8F, 0x86, 0x1B, 0xBB, 0x42, 0xE3, 0xC5, 0xE8, 0x54, 0xD3, 0x68, 0xB1, 0x45, 0x11,
    0x9E, 0x0A, 0xD2, 0x3C, 0xE6, 0x3B, 0x48, 0xEE, 0xE1, 0xE4, 0xAD, 0xD6, 0x44, 0xD2, 0x26, 0xB5, 0x71, 0xAA, 0xB5,
    0xE5, 0x79, 0xE3, 0x89, 0x4F, 0x4E, 0x33, 0xF7, 0xDE, 0x68, 0x21, 0xE7, 0x37, 0x4A, 0x23, 0xA8, 0xB8, 0x86, 0xD8,
    0x79, 0x50, 0xC7, 0x5E, 0x14, 0x51, 0x4C, 0xC1, 0x7E, 0xD5, 0xD0, 0xC4, 0x1C, 0xBF, 0x26, 0xF5, 0xA9, 0x7B, 0x9B,
    0x05, 0x2D, 0x3B, 0x10, 0x6A, 0x02, 0xD2, 0xFC, 0x06, 0x01, 0xBA, 0xED};

// This is the same section as the above encrypted section decrypted by sbtool so that after running
// the below decryption we can verify the results
static uint8_t s_decryptedSectionData[] = {
    0xE9, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x72, 0x07, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x10, 0x04, 0x00, 0x00, 0x9E, 0x42, 0xCE, 0x98, 0x00, 0x04, 0xFF, 0x1F, 0x01, 0x10, 0x01, 0x00, 0xFF,
    0x04, 0x01, 0x00, 0xB3, 0x07, 0x01, 0x00, 0xD7, 0x07, 0x01, 0x00, 0xE3, 0x07, 0x01, 0x00, 0xF9, 0x07, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x07, 0x01, 0x00, 0xFD, 0x07, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x01, 0x00, 0x01, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08,
    0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03,
    0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00,
    0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01,
    0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08,
    0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03,
    0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00,
    0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01,
    0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08, 0x01, 0x00, 0x03, 0x08,
    0x01, 0x00, 0x03, 0x08, 0x01, 0x00};

// The actual DEK of the above image calculated by sbtool
static uint8_t s_imageDEK[] = {0x04, 0x92, 0x25, 0x63, 0x50, 0x32, 0x6b, 0x0a,
                               0xd2, 0x72, 0x55, 0xb1, 0x72, 0x3f, 0xce, 0xe2};

// Vectors found at:
// http://www.inconteam.com/software-development/41-encryption/55-aes-test-vectors#aes-ecb-128
static uint8_t s_testVector1[] = {0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
                                  0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A};
static uint8_t s_testVector1Key[] = {0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
                                     0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C};
static uint8_t s_testVector1CypherText[] = {0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60,
                                            0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF, 0x97};

/*******************************************************************************
 * Code
 ******************************************************************************/

static void init_hardware(void)
{
    SIM->SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK |
                   SIM_SCGC5_PORTE_MASK);

    SIM->SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK; // set PLLFLLSEL to select the PLL for this clock source

#if defined(TOWER)
    // Enable the pins for LED
    PORT_BWR_PCR_MUX(PORTE, 6, 1);
    GPIO_CLR_PDDR(PTE, 0 << LED1_OFFSET);
    PORT_BWR_PCR_MUX(PORTE, 7, 1);
    PORT_BWR_PCR_MUX(PORTE, 8, 1);

    PTE->PDDR |= (1 << LED1_OFFSET) | (1 << LED2_OFFSET) | (1 << LED3_OFFSET);

#elif defined(FREEDOM)
    PORT_BWR_PCR_MUX(PORTB, 21, 1); // Set pin PTB21 to GPIO function
    PORT_BWR_PCR_MUX(PORTB, 22, 1); // Set pin PTB22 to GPIO function
    PORT_BWR_PCR_MUX(PORTE, 26, 1); // Set pin PTE26 to GPIO function

    GPIO_SET_PDDR(PTB_BASE, 1 << 21); // Blue LED, Negative Logic (0=on, 1=off)
    GPIO_SET_PDDR(PTB_BASE, 1 << 22); // Red LED, Negative Logic (0=on, 1=off)
    GPIO_SET_PDDR(PTB_BASE, 1 << 26); // Green LED, Negative Logic (0=on, 1=off)

#endif // FREEDOM
}

#if defined(TOWER)

static void led_toggle(uint32_t leds)
{
    if (leds & LED1)
    {
        PTE->PTOR |= (1 << LED1_OFFSET);
    }
    if (leds & LED2)
    {
        PTE->PTOR |= (1 << LED2_OFFSET);
    }
    if (leds & LED3)
    {
        PTE->PTOR |= (1 << LED3_OFFSET);
    }
}

#elif defined(FREEDOM)

// RGB-LED Control: 1=on, 0=off, for each of the 3 colors
void RGB(int Red, int Green, int Blue)
{
    if (Red == 1)
        GPIO_CLR_PDOR(PTB_BASE, 1 << 22);
    else
        GPIO_SET_PDOR(PTB_BASE, 1 << 22);

    if (Green == 1)
        GPIO_CLR_PDOR(PTE_BASE, 1 << 26);
    else
        GPIO_SET_PDOR(PTE_BASE, 1 << 26);

    if (Blue == 1)
        GPIO_CLR_PDOR(PTB_BASE, 1 << 21);
    else
        GPIO_SET_PDOR(PTB_BASE, 1 << 21);
}

#endif // FREEDOM

void delay(void)
{
    volatile uint32_t delayTicks = 2000000;

    while (delayTicks--)
    {
        __ASM("nop");
    }
}

// Blink them all
void success(void)
{
#if defined(TOWER)
    uint32_t leds = LED1;
    while (1)
    {
        led_toggle(leds);
        delay();
        led_toggle(leds);

        leds <<= 1;
        if (leds > LED3)
        {
            leds = LED1;
        }
    }
#elif defined(FREEDOM)
    RGB(0, 0, 0); // Start with all LEDs off

    while (1)
    {
        RGB(1, 0, 0);
        delay();
        RGB(0, 1, 0);
        delay();
        RGB(0, 0, 1);
        delay();
    }
#else
    while (1)
        ;
#endif // FREEDOM
}

// Just blink red LED
void failure(void)
{
#if defined(TOWER)
    while (1)
    {
        led_toggle(LED3);
        delay();
        led_toggle(LED3);
        delay();
    }
#elif defined(FREEDOM)
    RGB(0, 0, 0); // Start with all LEDs off

    while (1)
    {
        RGB(0, 0, 0); // Start with all LEDs off
        delay();
        RGB(1, 0, 0);
        delay();
    }
#else
    while (1)
        ;
#endif // FREEDOM
}

void test_vectors(void)
{
    uint32_t output[AES_BLOCK_SIZE_WORDS];
    uint32_t key[AES_BLOCK_SIZE_WORDS];

    memcpy(key, s_testVector1Key, sizeof(key));

    aes_init(key);

    memcpy(output, s_testVector1, sizeof(output));

    aes_encrypt(output, key, output);

    if (memcmp(output, s_testVector1CypherText, sizeof(output)) != 0)
    {
        failure();
    }
}

void main(void)
{
    unsigned int i;
    uint8_t *data = s_header;
    uint8_t mac_result[AES_128_KEY_SIZE];

    init_hardware();

    test_vectors();

    // Initialize the CBC-MAC with a default key and a zero IV
    cbc_mac_init(0, 0);

    // Read the first 7 chunks of data which is the Boot image header and 1 section table
    for (i = 0; i < 7; i++)
    {
        // since we are just doing 1 block at a time keep storing the mac result over itself
        cbc_mac_encrypt(data, CBC_BLOCK_SIZE, (uint8_t *)mac_result);

        data += CBC_BLOCK_SIZE;
    }

    // We are now pointing at the DEK dictionary, see if the mac entry in the dictionary matches the CBC-MAC we
    // calculated
    if (memcmp(data, mac_result, sizeof(mac_result)) == 0)
    {
        // If it does we now need to decrypt the next chunk which is the DEK with the initialization vector which is the
        // first chunk of
        // the header, and using our OTP key
        uint8_t dek[AES_128_KEY_SIZE];
        uint8_t *initVector = s_header;
        // increment data to the encrypted DEK
        data += CBC_BLOCK_SIZE;

        // Use default key with the init vector from the start of the header
        cbc_mac_init(0, initVector);

        // Decrypt the encrypted DEK into our unencrypted dek
        cbc_mac_decrypt(data, sizeof(dek), dek);

        if (memcmp(dek, s_imageDEK, sizeof(s_imageDEK)) == 0)
        {
            cbc_mac_init(dek, initVector);
            cbc_mac_decrypt(s_encryptedSectionData, CBC_BLOCK_SIZE, s_encryptedSectionData);

            cbc_mac_init(dek, initVector);
            cbc_mac_decrypt(s_encryptedSectionData + CBC_BLOCK_SIZE, sizeof(s_encryptedSectionData) - CBC_BLOCK_SIZE,
                            s_encryptedSectionData + CBC_BLOCK_SIZE);

            if (memcmp(s_encryptedSectionData, s_decryptedSectionData, sizeof(s_encryptedSectionData)) == 0)
            {
                success();
            }
        }
    }

    failure();
}

#if __ICCARM__

size_t __write(int handle, const unsigned char *buf, size_t size)
{
    return size;
}

#endif // __ICCARM__

/*******************************************************************************
 * EOF
 ******************************************************************************/
