/*
 * Copyright (c) 2015, Freescale Semiconductor, Inc.
 * Copyright 2016 NXP
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _FSL_SCG_H_
#define _FSL_SCG_H_

#include "fsl_common.h"

/*!
 * @addtogroup scg
 * @{
 */

/******************************************************************************
 * Definitions
 *****************************************************************************/
/* ## Start:DefineFront */
#if (defined(FSL_FEATURE_SOC_ULP1) && FSL_FEATURE_SOC_ULP1)
/*!
 * @brief Re-map the SCG peripheral base address for ULP1.
 * This driver is for SCG 0 on Core 0 of ULP1 only.
 */
#define SCG SCG0
#endif

#if (defined(FSL_FEATURE_SOC_ULP1) && FSL_FEATURE_SOC_ULP1)
/*!
 * @brief SCG (A/S)PLLPFD[PFDx] value.
 */
#define SCG_PLLPFD_PFD_VAL(pfdClkout, fracValue) ((uint32_t)((uint32_t)(fracValue) << pfdClkout))
/*!
 * @brief SCG (A/S)PLLPFD[PFD] mask.
 */
#define SCG_PLLPFD_PFD_MASK(pfdClkout) ((uint32_t)((uint32_t)(SCG_APLLPFD_PFD0_MASK) << pfdClkout))
/*!
 * @brief SCG (A/S)PLLPFD[PFDx_VALID] mask.
 */
#define SCG_PLLPFD_PFD_VALID_MASK(pfdClkout) ((uint32_t)(SCG_APLLPFD_PFD0_VALID_MASK << pfdClkout))
/*!
 * @brief SCG (A/S)PLLPFD[PFDx_CLKGATE] mask.
 */
#define SCG_PLLPFD_PFD_CLKGATE_MASK(pfdClkout) ((uint32_t)(SCG_APLLPFD_PFD0_CLKGATE_MASK << pfdClkout))
#endif

/*! @brief External XTAL0 (OSC0/SYSOSC) clock frequency.
 *
 * The XTAL0/EXTAL0 (OSC0/SYSOSC) clock frequency in Hz. When the clock is set up, use the
 * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
 * if XTAL0 is 8 MHz:
 * @code
 * CLOCK_InitSysOsc(...); // Set up the OSC0/SYSOSC
 * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value in the clock driver.
 * @endcode
 *
 * This is important for the multicore platforms where only one core needs to set up the
 * OSC0/SYSOSC using CLOCK_InitSysOsc. All other cores need to call the CLOCK_SetXtal0Freq
 * to get a valid clock frequency.
 */
extern uint32_t g_xtal0Freq;

#if (!(defined(FSL_FEATURE_SOC_NO_XTAL32_RTCCLKIN) && FSL_FEATURE_SOC_NO_XTAL32_RTCCLKIN))
/*! @brief External XTAL32/EXTAL32 clock frequency.
 *
 * The XTAL32/EXTAL32 clock frequency in Hz. When the clock is set up, use the
 * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 *
 * This is important for the multicore platforms where only one core needs to set up
 * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 * to get a valid clock frequency.
 */
extern uint32_t g_xtal32Freq;
#endif /* FSL_FEATURE_SOC_NO_XTAL32_RTCCLKIN */

#if (defined(FSL_FEATURE_SOC_HAS_LVDS) && FSL_FEATURE_SOC_HAS_LVDS)
/*! @brief External LVDS pad clock frequency.
 *
 * The LVDS pad clock frequency in Hz. When the clock is set up, use the
 * function CLOCK_SetLvdsFreq to set the value in the clock driver.
 *
 */
extern uint32_t g_lvdsFreq;
#endif /* FSL_FEATURE_SOC_HAS_LVDS */
/* ## End:DefineFront */

/* ## Start:DefineBack */
#if (defined(FSL_FEATURE_SOC_OSC32_COUNT) && FSL_FEATURE_SOC_OSC32_COUNT)
/*!
 * @brief OSC32 work mode.
 */
typedef enum _osc32_mode
{
    kOSC32_Bypass = OSC32_CR_ROSCEN_MASK, /*!< Bypass mode, use external input clock directly. */
    kOSC32_Crystal = OSC32_CR_ROSCEN_MASK | OSC32_CR_ROSCEREFS_MASK, /*!< Crystal mode, does not work in stop mode. */
    kOSC32_CrystalEnableInStop = OSC32_CR_ROSCEN_MASK
                               | OSC32_CR_ROSCSTPEN_MASK
                               | OSC32_CR_ROSCEREFS_MASK, /*!< Crystal mode, still work in stop mode. */
} osc32_mode_t;
#endif /* FSL_FEATURE_SOC_OSC32_COUNT */

/*!
 * @brief SCG status return codes.
 */
enum _scg_status
{
    kStatus_SCG_Busy = MAKE_STATUS(kStatusGroup_SCG, 1),      /*!< Clock is busy.  */
    kStatus_SCG_InvalidSrc = MAKE_STATUS(kStatusGroup_SCG, 2) /*!< Invalid source. */
};

/*!
 * @brief SCG system clock type.
 */
typedef enum _scg_sys_clk
{
    kSCG_SysClkSlow, /*!< System slow clock. */
#if (defined(FSL_FEATURE_SCG_HAS_DIVBUS) && FSL_FEATURE_SCG_HAS_DIVBUS)
    kSCG_SysClkBus, /*!< Bus clock.         */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_DIVEXT) && FSL_FEATURE_SCG_HAS_DIVEXT)
    kSCG_SysClkExt, /*!< External clock.    */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_DIVPLAT) && FSL_FEATURE_SCG_HAS_DIVPLAT)
    kSCG_SysClkPlat, /*!< Platform clock.    */
#endif
    kSCG_SysClkCore, /*!< Core clock.        */
} scg_sys_clk_t;

/*!
 * @brief SCG system clock source.
 */
typedef enum _scg_sys_clk_src
{
    kSCG_SysClkSrcSysOsc = 1U, /*!< System OSC. */
    kSCG_SysClkSrcSirc = 2U,   /*!< Slow IRC.   */
    kSCG_SysClkSrcFirc = 3U,   /*!< Fast IRC.   */
#if (defined(FSL_FEATURE_SCG_HAS_ROSC_SYS_CLK_SRC) && FSL_FEATURE_SCG_HAS_ROSC_SYS_CLK_SRC)
    kSCG_SysClkSrcRosc = 4U,  /*!< RTC OSC. */
#endif /* FSL_FEATURE_SCG_HAS_ROSC_SYS_CLK_SRC */
#if (defined(FSL_FEATURE_SCG_HAS_LPFLL) && FSL_FEATURE_SCG_HAS_LPFLL)
    kSCG_SysClkSrcLpFll = 5U,  /*!< Low power FLL. */
#endif /* FSL_FEATURE_SCG_HAS_LPFLL */
#if (defined(FSL_FEATURE_SCG_HAS_APLL) && FSL_FEATURE_SCG_HAS_APLL)
    kSCG_SysClkSrcAuxPll = 5U,  /*!< Auxiliary PLL. */
#endif /* FSL_FEATURE_SCG_HAS_APLL */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL) && FSL_FEATURE_SCG_HAS_SPLL)
    kSCG_SysClkSrcSysPll = 6U  /*!< System PLL. */
#endif /* FSL_FEATURE_SCG_HAS_SPLL */
} scg_sys_clk_src_t;

/*!
 * @brief SCG system clock divider value.
 */
typedef enum _scg_sys_clk_div
{
    kSCG_SysClkDivBy1 = 0U,   /*!< Divided by 1.  */
    kSCG_SysClkDivBy2 = 1U,   /*!< Divided by 2.  */
    kSCG_SysClkDivBy3 = 2U,   /*!< Divided by 3.  */
    kSCG_SysClkDivBy4 = 3U,   /*!< Divided by 4.  */
    kSCG_SysClkDivBy5 = 4U,   /*!< Divided by 5.  */
    kSCG_SysClkDivBy6 = 5U,   /*!< Divided by 6.  */
    kSCG_SysClkDivBy7 = 6U,   /*!< Divided by 7.  */
    kSCG_SysClkDivBy8 = 7U,   /*!< Divided by 8.  */
    kSCG_SysClkDivBy9 = 8U,   /*!< Divided by 9.  */
    kSCG_SysClkDivBy10 = 9U,  /*!< Divided by 10. */
    kSCG_SysClkDivBy11 = 10U, /*!< Divided by 11. */
    kSCG_SysClkDivBy12 = 11U, /*!< Divided by 12. */
    kSCG_SysClkDivBy13 = 12U, /*!< Divided by 13. */
    kSCG_SysClkDivBy14 = 13U, /*!< Divided by 14. */
    kSCG_SysClkDivBy15 = 14U, /*!< Divided by 15. */
    kSCG_SysClkDivBy16 = 15U  /*!< Divided by 16. */
} scg_sys_clk_div_t;

/*!
 * @brief SCG system clock configuration.
 */
typedef struct _scg_sys_clk_config
{
    uint32_t divSlow : 4; /*!< Slow clock divider, see @ref scg_sys_clk_div_t. */
#if (defined(FSL_FEATURE_SCG_HAS_DIVBUS) && FSL_FEATURE_SCG_HAS_DIVBUS)
    uint32_t divBus : 4; /*!< Bus clock divider, see @ref scg_sys_clk_div_t.  */
#else
    uint32_t : 4; /*!< Reserved. */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_DIVEXT) && FSL_FEATURE_SCG_HAS_DIVEXT)
    uint32_t divExt : 4; /*!< External clock divider, see @ref scg_sys_clk_div_t.  */
#else
    uint32_t : 4; /*!< Reserved. */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_DIVPLAT) && FSL_FEATURE_SCG_HAS_DIVPLAT)
    uint32_t divPlat : 4; /*!< Platform clock divider, which can only be divided by 1. See @ref kSCG_SysClkDivBy1.*/
#else
    uint32_t : 4; /*!< Reserved. */
#endif
    uint32_t divCore : 4; /*!< Core clock divider, see @ref scg_sys_clk_div_t. */
    uint32_t : 4; /*!< Reserved. */
    uint32_t src : 4; /*!< System clock source, see @ref scg_sys_clk_src_t. */
    uint32_t : 4; /*!< reserved. */
} scg_sys_clk_config_t;

#if (defined(FSL_FEATURE_SCG_HAS_CLKOUTCNFG) && FSL_FEATURE_SCG_HAS_CLKOUTCNFG)
/*!
 * @brief SCG clock out configuration (CLKOUTSEL).
 */
typedef enum _clock_clkout_src
{
#if (defined(FSL_FEATURE_SCG_HAS_SLOW_CLKOUT) && FSL_FEATURE_SCG_HAS_SLOW_CLKOUT)
    kClockClkoutSelScgSlow = 0U, /*!< SCG slow clock. */
#endif /* FSL_FEATURE_SCG_HAS_SLOW_CLKOUT */
#if (defined(FSL_FEATURE_SCG_HAS_EXT_CLKOUT) && FSL_FEATURE_SCG_HAS_EXT_CLKOUT)
    kClockClkoutSelScgExt = 0U, /*!< SCG external clock. */
#endif /* FSL_FEATURE_SCG_HAS_EXT_CLKOUT */
    kClockClkoutSelSysOsc = 1U,  /*!< System OSC.     */
    kClockClkoutSelSirc = 2U,    /*!< Slow IRC.       */
    kClockClkoutSelFirc = 3U,    /*!< Fast IRC.       */
#if (defined(FSL_FEATURE_SCG_HAS_ROSC_CLKOUT) && FSL_FEATURE_SCG_HAS_ROSC_CLKOUT)
    kClockClkoutSelScgRtcOsc = 4U, /*!< SCG RTC OSC clock. */
#endif /* FSL_FEATURE_SCG_HAS_ROSC_CLKOUT */
#if (defined(FSL_FEATURE_SCG_HAS_LPFLL) && FSL_FEATURE_SCG_HAS_LPFLL)
    kClockClkoutSelLpFll = 5U,    /*!< Low power FLL.  */
#endif /* FSL_FEATURE_SCG_HAS_LPFLL */
#if (defined(FSL_FEATURE_SCG_HAS_APLL_CLKOUT) && FSL_FEATURE_SCG_HAS_APLL_CLKOUT)
    kClockClkoutSelScgAuxPll = 5U, /*!< SCG Auxiliary PLL clock. */
#endif /* FSL_FEATURE_SCG_HAS_APLL_CLKOUT */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL) && FSL_FEATURE_SCG_HAS_SPLL)
    kClockClkoutSelSysPll = 6U   /*!< System PLL.     */
#endif /* FSL_FEATURE_SCG_HAS_SPLL */
} clock_clkout_src_t;
#endif /* FSL_FEATURE_SCG_HAS_CLKOUTCNFG */

/*!
 * @brief SCG asynchronous clock type.
 */
typedef enum _scg_async_clk
{
    kSCG_AsyncDiv1Clk, /*!< The async clock by DIV1, e.g. SOSCDIV1_CLK, SIRCDIV1_CLK. */
    kSCG_AsyncDiv2Clk, /*!< The async clock by DIV2, e.g. SOSCDIV2_CLK, SIRCDIV2_CLK. */
#if ((defined(FSL_FEATURE_SCG_HAS_SOSCDIV3) && FSL_FEATURE_SCG_HAS_SOSCDIV3) || \
     (defined(FSL_FEATURE_SCG_HAS_SIRCDIV3) && FSL_FEATURE_SCG_HAS_SIRCDIV3) || \
     (defined(FSL_FEATURE_SCG_HAS_FIRCDIV3) && FSL_FEATURE_SCG_HAS_FIRCDIV3) || \
     (defined(FSL_FEATURE_SCG_HAS_SPLLDIV3) && FSL_FEATURE_SCG_HAS_SPLLDIV3) || \
     (defined(FSL_FEATURE_SCG_HAS_FLLDIV3) && FSL_FEATURE_SCG_HAS_FLLDIV3))
    kSCG_AsyncDiv3Clk  /*!< The async clock by DIV3, e.g. SOSCDIV3_CLK, SIRCDIV3_CLK. */
#endif
} scg_async_clk_t;

/*!
 * @brief SCG asynchronous clock divider value.
 */
typedef enum scg_async_clk_div
{
    kSCG_AsyncClkDisable = 0U, /*!< Clock output is disabled.  */
    kSCG_AsyncClkDivBy1 = 1U,  /*!< Divided by 1.              */
    kSCG_AsyncClkDivBy2 = 2U,  /*!< Divided by 2.              */
    kSCG_AsyncClkDivBy4 = 3U,  /*!< Divided by 4.              */
    kSCG_AsyncClkDivBy8 = 4U,  /*!< Divided by 8.              */
    kSCG_AsyncClkDivBy16 = 5U, /*!< Divided by 16.             */
    kSCG_AsyncClkDivBy32 = 6U, /*!< Divided by 32.             */
    kSCG_AsyncClkDivBy64 = 7U  /*!< Divided by 64.             */
} scg_async_clk_div_t;

/*!
 * @brief SCG system OSC monitor mode.
 */
typedef enum _scg_sosc_monitor_mode
{
    kSCG_SysOscMonitorDisable = 0U,                  /*!< Monitor disabled.                          */
    kSCG_SysOscMonitorInt = SCG_SOSCCSR_SOSCCM_MASK, /*!< Interrupt when the system OSC error is detected. */
    kSCG_SysOscMonitorReset =
        SCG_SOSCCSR_SOSCCM_MASK | SCG_SOSCCSR_SOSCCMRE_MASK /*!< Reset when the system OSC error is detected.     */
} scg_sosc_monitor_mode_t;

#if (defined(FSL_FEATURE_SCG_HAS_OSC_SCXP) && FSL_FEATURE_SCG_HAS_OSC_SCXP)
/*! @brief Oscillator capacitor load setting.*/
enum _scg_sosc_cap_load
{
    kSCG_SysOscCap2P = SCG_SOSCCFG_SC2P_MASK,  /*!< 2  pF capacitor load */
    kSCG_SysOscCap4P = SCG_SOSCCFG_SC4P_MASK,  /*!< 4  pF capacitor load */
    kSCG_SysOscCap8P = SCG_SOSCCFG_SC8P_MASK,  /*!< 8  pF capacitor load */
    kSCG_SysOscCap16P = SCG_SOSCCFG_SC16P_MASK /*!< 16 pF capacitor load */
};
#endif /* FSL_FEATURE_SCG_HAS_OSC_SCXP */

#if !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCFG) && FSL_FEATURE_SCG_HAS_NO_SOSCCFG)
/*! @brief OSC work mode. */
typedef enum _scg_sosc_mode
{
    kSCG_SysOscModeExt = 0U,                                                   /*!< Use external clock.   */
    kSCG_SysOscModeOscLowPower = SCG_SOSCCFG_EREFS_MASK,                       /*!< Oscillator low power. */
    kSCG_SysOscModeOscHighGain = SCG_SOSCCFG_EREFS_MASK | SCG_SOSCCFG_HGO_MASK /*!< Oscillator high gain. */
} scg_sosc_mode_t;
#endif /* FSL_FEATURE_SCG_HAS_NO_SOSCCFG */

#if ( !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCEN)     || \
      !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCSTEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCSTEN) || \
      !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCLPEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCLPEN) || \
       (defined(FSL_FEATURE_SCG_HAS_OSC_ERCLK) && FSL_FEATURE_SCG_HAS_OSC_ERCLK) )
/*! @brief OSC enable mode. */
enum _scg_sosc_enable_mode
{
#if !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCEN)
    kSCG_SysOscEnable = SCG_SOSCCSR_SOSCEN_MASK,             /*!< Enable OSC clock. */
#endif /* FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCEN */
#if !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCSTEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCSTEN)
    kSCG_SysOscEnableInStop = SCG_SOSCCSR_SOSCSTEN_MASK,     /*!< Enable OSC in stop mode. */
#endif /* FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCSTEN */
#if !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCLPEN) && FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCLPEN)
    kSCG_SysOscEnableInLowPower = SCG_SOSCCSR_SOSCLPEN_MASK, /*!< Enable OSC in low power mode. */
#endif /* FSL_FEATURE_SCG_HAS_NO_SOSCCSR_SOSCLPEN */
#if (defined(FSL_FEATURE_SCG_HAS_OSC_ERCLK) && FSL_FEATURE_SCG_HAS_OSC_ERCLK)
    kSCG_SysOscEnableErClk = SCG_SOSCCSR_SOSCERCLKEN_MASK    /*!< Enable OSCERCLK. */
#endif /* FSL_FEATURE_SCG_HAS_OSC_ERCLK */
};
#endif

/*!
 * @brief SCG system OSC configuration.
 */
typedef struct _scg_sosc_config
{
    uint32_t freq;                       /*!< System OSC frequency.                    */
    scg_sosc_monitor_mode_t monitorMode; /*!< Clock monitor mode selected.     */
    uint8_t enableMode;                  /*!< Enable mode, OR'ed value of _scg_sosc_enable_mode.  */

    scg_async_clk_div_t div1; /*!< SOSCDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< SOSCDIV2 value.                          */
#if (defined(FSL_FEATURE_SCG_HAS_SOSCDIV3) && FSL_FEATURE_SCG_HAS_SOSCDIV3)
    scg_async_clk_div_t div3; /*!< SOSCDIV3 value.                          */
#endif /* FSL_FEATURE_SCG_HAS_SOSCDIV3 */

#if (defined(FSL_FEATURE_SCG_HAS_OSC_SCXP) && FSL_FEATURE_SCG_HAS_OSC_SCXP)
    uint32_t capLoad;         /*!< Capacitor load, OR'ed value of _scg_sosc_cap_load. */
#endif                        /* FSL_FEATURE_SCG_HAS_OSC_SCXP */
#if !(defined(FSL_FEATURE_SCG_HAS_NO_SOSCCFG) && FSL_FEATURE_SCG_HAS_NO_SOSCCFG)
    scg_sosc_mode_t workMode; /*!< OSC work mode.                           */
#endif /* FSL_FEATURE_SCG_HAS_NO_SOSCCFG */
} scg_sosc_config_t;

/*!
 * @brief SCG slow IRC clock frequency range.
 */
typedef enum _scg_sirc_range
{
    kSCG_SircRangeLow, /*!< Slow IRC low range clock (2 MHz, 4 MHz for i.MX 7 ULP).  */
    kSCG_SircRangeHigh /*!< Slow IRC high range clock (8 MHz, 16 MHz for i.MX 7 ULP). */
} scg_sirc_range_t;

/*! @brief SIRC enable mode. */
enum _scg_sirc_enable_mode
{
    kSCG_SircEnable = SCG_SIRCCSR_SIRCEN_MASK,            /*!< Enable SIRC clock.             */
    kSCG_SircEnableInStop = SCG_SIRCCSR_SIRCSTEN_MASK,    /*!< Enable SIRC in stop mode.      */
    kSCG_SircEnableInLowPower = SCG_SIRCCSR_SIRCLPEN_MASK /*!< Enable SIRC in low power mode. */
};

/*!
 * @brief SCG slow IRC clock configuration.
 */
typedef struct _scg_sirc_config
{
    uint32_t enableMode; /*!< Enable mode, OR'ed value of _scg_sirc_enable_mode. */
    scg_async_clk_div_t div1; /*!< SIRCDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< SIRCDIV2 value.                          */
#if (defined(FSL_FEATURE_SCG_HAS_SIRCDIV3) && FSL_FEATURE_SCG_HAS_SIRCDIV3)
    scg_async_clk_div_t div3; /*!< SIRCDIV3 value.                          */
#endif /* FSL_FEATURE_SCG_HAS_SIRCDIV3 */

    scg_sirc_range_t range; /*!< Slow IRC frequency range.                */
} scg_sirc_config_t;

/*!
 * @brief SCG fast IRC trim mode.
 */
typedef enum _scg_firc_trim_mode
{
    kSCG_FircTrimNonUpdate = SCG_FIRCCSR_FIRCTREN_MASK,
    /*!< FIRC trim enable but not enable trim value update. In this mode, the
     trim value is fixed to the initialized value which is defined by
     trimCoar and trimFine in configure structure \ref scg_firc_trim_config_t.*/

    kSCG_FircTrimUpdate = SCG_FIRCCSR_FIRCTREN_MASK | SCG_FIRCCSR_FIRCTRUP_MASK
    /*!< FIRC trim enable and trim value update enable. In this mode, the trim
     value is auto update. */

} scg_firc_trim_mode_t;

#if !(defined(FSL_FEATURE_SCG_HAS_NO_FIRCTCFG) && FSL_FEATURE_SCG_HAS_NO_FIRCTCFG)
/*!
 * @brief SCG fast IRC trim predivided value for system OSC.
 */
typedef enum _scg_firc_trim_div
{
    kSCG_FircTrimDivBy1,    /*!< Divided by 1.    */
    kSCG_FircTrimDivBy128,  /*!< Divided by 128.  */
    kSCG_FircTrimDivBy256,  /*!< Divided by 256.  */
    kSCG_FircTrimDivBy512,  /*!< Divided by 512.  */
    kSCG_FircTrimDivBy1024, /*!< Divided by 1024. */
    kSCG_FircTrimDivBy2048  /*!< Divided by 2048. */
} scg_firc_trim_div_t;

/*!
 * @brief SCG fast IRC trim source.
 */
typedef enum _scg_firc_trim_src
{
#if (defined(FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_USB0) && FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_USB0)
    kSCG_FircTrimSrcUsb0   = 0U, /*!< USB0 start of frame (1kHz). */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_USB1) && FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_USB1)
    kSCG_FircTrimSrcUsb1   = 1U, /*!< USB1 start of frame (1kHz). */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_SOSC) && FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_SOSC)
    kSCG_FircTrimSrcSysOsc = 2U, /*!< System OSC.                 */
#endif
#if (defined(FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_RTCOSC) && FSL_FEATURE_SCG_HAS_FIRC_TRIMSRC_RTCOSC)
    kSCG_FircTrimSrcRtcOsc = 3U, /*!< RTC OSC (32.768 kHz).       */
#endif
} scg_firc_trim_src_t;
#endif /* FSL_FEATURE_SCG_HAS_NO_FIRCTCFG */

/*!
 * @brief SCG fast IRC clock trim configuration.
 */
typedef struct _scg_firc_trim_config
{
    scg_firc_trim_mode_t trimMode; /*!< FIRC trim mode.                       */
#if !(defined(FSL_FEATURE_SCG_HAS_NO_FIRCTCFG) && FSL_FEATURE_SCG_HAS_NO_FIRCTCFG)
    scg_firc_trim_src_t trimSrc; /*!< Trim source.                          */
    scg_firc_trim_div_t trimDiv; /*!< Trim predivided value for the system OSC.  */
#endif /* FSL_FEATURE_SCG_HAS_NO_FIRCTCFG */

    uint8_t trimCoar; /*!< Trim coarse value; Irrelevant if trimMode is kSCG_FircTrimUpdate. */
    uint8_t trimFine; /*!< Trim fine value; Irrelevant if trimMode is kSCG_FircTrimUpdate. */
} scg_firc_trim_config_t;

/*!
 * @brief SCG fast IRC clock frequency range.
 */
typedef enum _scg_firc_range
{
    kSCG_FircRange48M, /*!< Fast IRC is trimmed to 48 MHz.  */
    kSCG_FircRange52M, /*!< Fast IRC is trimmed to 52 MHz.  */
    kSCG_FircRange56M, /*!< Fast IRC is trimmed to 56 MHz.  */
    kSCG_FircRange60M  /*!< Fast IRC is trimmed to 60 MHz.  */
} scg_firc_range_t;

/*! @brief FIRC enable mode. */
enum _scg_firc_enable_mode
{
    kSCG_FircEnable = SCG_FIRCCSR_FIRCEN_MASK,              /*!< Enable FIRC clock.             */
    kSCG_FircEnableInStop = SCG_FIRCCSR_FIRCSTEN_MASK,      /*!< Enable FIRC in stop mode.      */
#if (defined(FSL_FEATURE_SCG_HAS_FIRCLPEN) && FSL_FEATURE_SCG_HAS_FIRCLPEN)
    kSCG_FircEnableInLowPower = SCG_FIRCCSR_FIRCLPEN_MASK,  /*!< Enable FIRC in low power mode. */
#endif /* FSL_FEATURE_SCG_HAS_FIRCLPEN */
#if (defined(FSL_FEATURE_SCG_HAS_FIRCREGOFF) && FSL_FEATURE_SCG_HAS_FIRCREGOFF)
    kSCG_FircDisableRegulator = SCG_FIRCCSR_FIRCREGOFF_MASK /*!< Disable regulator.             */
#endif /* FSL_FEATURE_SCG_HAS_FIRCREGOFF */
};

/*!
 * @brief SCG fast IRC clock configuration.
 */
typedef struct _scg_firc_config_t
{
    uint32_t enableMode; /*!< Enable mode, OR'ed value of _scg_firc_enable_mode. */

    scg_async_clk_div_t div1; /*!< FIRCDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< FIRCDIV2 value.                          */
#if (defined(FSL_FEATURE_SCG_HAS_FIRCDIV3) && FSL_FEATURE_SCG_HAS_FIRCDIV3)
    scg_async_clk_div_t div3; /*!< FIRCDIV3 value.                          */
#endif /* FSL_FEATURE_SCG_HAS_FIRCDIV3 */

    scg_firc_range_t range; /*!< Fast IRC frequency range.                 */

    const scg_firc_trim_config_t *trimConfig; /*!< Pointer to the FIRC trim configuration; set NULL to disable trim. */
} scg_firc_config_t;

#if (defined(FSL_FEATURE_SCG_HAS_SPLL) && FSL_FEATURE_SCG_HAS_SPLL)
/*!
 * @brief SCG system PLL clock source.
 */
typedef enum _scg_spll_src
{
    kSCG_SysPllSrcSysOsc, /*!< System PLL clock source is system OSC. */
    kSCG_SysPllSrcFirc    /*!< System PLL clock source is fast IRC.   */
} scg_spll_src_t;

#if (defined(FSL_FEATURE_SCG_HAS_SPLL_MONITOR) && FSL_FEATURE_SCG_HAS_SPLL_MONITOR)
/*!
 * @brief SCG system PLL monitor mode.
 */
typedef enum _scg_spll_monitor_mode
{
    kSCG_SysPllMonitorDisable = 0U,                  /*!< Monitor disabled.                          */
    kSCG_SysPllMonitorInt = SCG_SPLLCSR_SPLLCM_MASK, /*!< Interrupt when the system PLL error is detected. */
    kSCG_SysPllMonitorReset =
        SCG_SPLLCSR_SPLLCM_MASK | SCG_SPLLCSR_SPLLCMRE_MASK /*!< Reset when the system PLL error is detected.     */
} scg_spll_monitor_mode_t;
#endif /* FSL_FEATURE_SCG_HAS_SPLL_MONITOR */

/*! @brief SPLL enable mode. */
enum _scg_spll_enable_mode
{
    kSCG_SysPllEnable = SCG_SPLLCSR_SPLLEN_MASK,        /*!< Enable SPLL clock.             */
    kSCG_SysPllEnableInStop = SCG_SPLLCSR_SPLLSTEN_MASK /*!< Enable SPLL in stop mode.      */
};

#if (defined(FSL_FEATURE_SCG_HAS_SPLLPFD) && FSL_FEATURE_SCG_HAS_SPLLPFD)
/*!
 * @brief SCG system PLL PFD clouk out select.
 */
typedef enum _scg_spll_pfd_clkout
{
    kSCG_SysPllPfd0Clk = 0U, /*!< PFD0 output clock selected. */
    kSCG_SysPllPfd1Clk = 8U, /*!< PFD1 output clock selected. */
    kSCG_SysPllPfd2Clk = 16U, /*!< PFD2 output clock selected. */
    kSCG_SysPllPfd3Clk = 24U  /*!< PFD3 output clock selected. */
} scg_spll_pfd_clkout_t;
#endif /* FSL_FEATURE_SCG_HAS_SPLLPFD */

/*!
 * @brief SCG system PLL configuration.
 */
typedef struct _scg_spll_config
{
    uint8_t enableMode;                  /*!< Enable mode, OR'ed value of _scg_spll_enable_mode */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL_MONITOR) && FSL_FEATURE_SCG_HAS_SPLL_MONITOR)
    scg_spll_monitor_mode_t monitorMode; /*!< Clock monitor mode selected.     */
#endif /* FSL_FEATURE_SCG_HAS_SPLL_MONITOR */

    scg_async_clk_div_t div1; /*!< SPLLDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< SPLLDIV2 value.                          */
#if (defined(FSL_FEATURE_SCG_HAS_SPLLDIV3) && FSL_FEATURE_SCG_HAS_SPLLDIV3)
    scg_async_clk_div_t div3; /*!< SPLLDIV3 value.                          */
#endif /* FSL_FEATURE_SCG_HAS_SPLLDIV3 */

    scg_spll_src_t src; /*!< Clock source.                            */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL_PLLS) && FSL_FEATURE_SCG_HAS_SPLL_PLLS)
    bool isPfdSelected; /*!< SPLL PFD output clock selected.             */
#endif /* FSL_FEATURE_SCG_HAS_SPLL_PLLS */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL_BYPASS) && FSL_FEATURE_SCG_HAS_SPLL_BYPASS)
    bool isBypassSelected; /*!< LVDS pad (external) clock selected.             */
#endif /* FSL_FEATURE_SCG_HAS_SPLL_BYPASS */
    uint8_t prediv;     /*!< PLL reference clock divider.             */
#if (defined(FSL_FEATURE_SCG_HAS_SPLL_PFDSEL) && FSL_FEATURE_SCG_HAS_SPLL_PFDSEL)
    scg_spll_pfd_clkout_t pfdClkout; /*!< PLL PFD clouk out select.             */
#endif /* FSL_FEATURE_SCG_HAS_SPLL_PFDSEL */
    uint8_t mult;       /*!< System PLL multiplier.                   */
#if (defined(FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1) && FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1)
    scg_sys_clk_div_t pllPostdiv1; /*!< System PLL Post Clock Divide1 Ratio.     */
#endif /* FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1 */
#if (defined(FSL_FEATURE_SCG_HAS_SPLLPOSTDIV2) && FSL_FEATURE_SCG_HAS_SPLLPOSTDIV2)
    scg_sys_clk_div_t pllPostdiv2; /*!< System PLL Post Clock Divide2 Ratio.     */
#endif /* FSL_FEATURE_SCG_HAS_SPLLPOSTDIV2 */
} scg_spll_config_t;
#endif /* FSL_FEATURE_SCG_HAS_SPLL */

#if (defined(FSL_FEATURE_SCG_HAS_LPFLL) && FSL_FEATURE_SCG_HAS_LPFLL)

/*! @brief LPFLL enable mode. */
enum _scg_lpfll_enable_mode
{
    kSCG_LpFllEnable = SCG_LPFLLCSR_LPFLLEN_MASK,        /*!< Enable LPFLL clock.             */
#if (defined(FSL_FEATURE_SCG_HAS_LPFLLSTEN) && FSL_FEATURE_SCG_HAS_LPFLLSTEN)
    kSCG_LpFllEnableInStop = SCG_LPFLLCSR_LPFLLSTEN_MASK /*!< Enable LPFLL in stop mode.      */
#endif /* FSL_FEATURE_SCG_HAS_LPFLLSTEN */
};

/*!
 * @brief SCG LPFLL clock frequency range.
 */
typedef enum _scg_lpfll_range
{
    kSCG_LpFllRange48M,  /*!< LPFLL is trimmed to 48MHz.  */
    kSCG_LpFllRange72M,  /*!< LPFLL is trimmed to 72MHz.  */
    kSCG_LpFllRange96M,  /*!< LPFLL is trimmed to 96MHz.  */
    kSCG_LpFllRange120M  /*!< LPFLL is trimmed to 120MHz. */
} scg_lpfll_range_t;

/*!
 * @brief SCG LPFLL trim mode.
 */
typedef enum _scg_lpfll_trim_mode
{
    kSCG_LpFllTrimNonUpdate = SCG_LPFLLCSR_LPFLLTREN_MASK,
    /*!< LPFLL trim is enabled but the trim value update is not enabled. In this mode, the
     trim value is fixed to the initialized value, which is defined by the @ref trimValue
     in the structure @ref scg_lpfll_trim_config_t.*/

    kSCG_LpFllTrimUpdate = SCG_LPFLLCSR_LPFLLTREN_MASK | SCG_LPFLLCSR_LPFLLTRUP_MASK
    /*!< FIRC trim is enabled and trim value update is enabled. In this mode, the trim
     value is automatically updated. */
} scg_lpfll_trim_mode_t;

/*!
 * @brief SCG LPFLL trim source.
 */
typedef enum _scg_lpfll_trim_src
{
    kSCG_LpFllTrimSrcSirc   = 0U, /*!< SIRC.                 */
    kSCG_LpFllTrimSrcFirc   = 1U, /*!< FIRC.                 */
    kSCG_LpFllTrimSrcSysOsc = 2U, /*!< System OSC.           */
    kSCG_LpFllTrimSrcRtcOsc = 3U, /*!< RTC OSC (32.768 kHz). */
} scg_lpfll_trim_src_t;

/*!
 * @brief SCG LPFLL lock mode.
 */
typedef enum _scg_lpfll_lock_mode
{
    kSCG_LpFllLock1Lsb = 0U, /*!< Lock with 1 LSB. */
    kSCG_LpFllLock2Lsb = 1U  /*!< Lock with 2 LSB. */
} scg_lpfll_lock_mode_t;

/*!
 * @brief SCG LPFLL clock trim configuration.
 */
typedef struct _scg_lpfll_trim_config
{
    scg_lpfll_trim_mode_t trimMode; /*!< Trim mode.            */
    scg_lpfll_lock_mode_t lockMode; /*!< Lock mode; Irrelevant if the trimMode is kSCG_LpFllTrimNonUpdate. */

    scg_lpfll_trim_src_t trimSrc;   /*!< Trim source.          */
    uint8_t trimDiv;                /*!< Trim predivideds value, which can be 0 ~ 31.
                                      [ Trim source frequency / (trimDiv + 1) ] must be 2 MHz or 32768 Hz. */

    uint8_t trimValue;              /*!< Trim value; Irrelevant if trimMode is the kSCG_LpFllTrimUpdate. */
} scg_lpfll_trim_config_t;

/*!
 * @brief SCG low power FLL configuration.
 */
typedef struct _scg_lpfll_config
{
    uint8_t enableMode;                  /*!< Enable mode, OR'ed value of _scg_lpfll_enable_mode */

    scg_async_clk_div_t div1; /*!< LPFLLDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< LPFLLDIV2 value.                          */
#if (defined(FSL_FEATURE_SCG_HAS_FLLDIV3) && FSL_FEATURE_SCG_HAS_FLLDIV3)
    scg_async_clk_div_t div3; /*!< LPFLLDIV3 value.                          */
#endif /* FSL_FEATURE_SCG_HAS_FLLDIV3 */

    scg_lpfll_range_t range; /*!< LPFLL frequency range.                     */

    const scg_lpfll_trim_config_t *trimConfig; /*!< Trim configuration; set NULL to disable trim. */
} scg_lpfll_config_t;

#endif /* FSL_FEATURE_SCG_HAS_LPFLL */

#if (defined(FSL_FEATURE_SCG_HAS_ROSC) && FSL_FEATURE_SCG_HAS_ROSC)
/*!
 * @brief SCG RTC OSC monitor mode.
 */
typedef enum _scg_rosc_monitor_mode
{
    kSCG_rtcOscMonitorDisable = 0U,                  /*!< Monitor disable.                          */
    kSCG_rtcOscMonitorInt = SCG_ROSCCSR_ROSCCM_MASK, /*!< Interrupt when the RTC OSC error is detected. */
    kSCG_rtcOscMonitorReset =
        SCG_ROSCCSR_ROSCCM_MASK | SCG_ROSCCSR_ROSCCMRE_MASK /*!< Reset when the RTC OSC error is detected.     */
} scg_rosc_monitor_mode_t;

/*!
 * @brief SCG RTC OSC configuration.
 */
typedef struct _scg_rosc_config
{
    scg_rosc_monitor_mode_t monitorMode; /*!< Clock monitor mode selected.     */
} scg_rosc_config_t;
#endif /* FSL_FEATURE_SCG_HAS_ROSC */

#if (defined(FSL_FEATURE_SCG_HAS_APLL) && FSL_FEATURE_SCG_HAS_APLL)
/*!
 * @brief SCG auxiliary PLL clock source.
 */
typedef enum _scg_apll_src
{
    kSCG_AuxPllSrcSysOsc, /*!< Auxiliary PLL clock source is the system OSC. */
    kSCG_AuxPllSrcFirc    /*!< Auxiliary PLL clock source is the fast IRC.   */
} scg_apll_src_t;

/*! @brief APLL enable mode. */
enum _scg_apll_enable_mode
{
    kSCG_AuxPllEnable = SCG_APLLCSR_APLLEN_MASK,        /*!< Enable APLL clock.             */
    kSCG_AuxPllEnableInStop = SCG_APLLCSR_APLLSTEN_MASK /*!< Enable APLL in stop mode.      */
};

/*!
 * @brief SCG auxiliary PLL PFD clouk out select.
 */
typedef enum _scg_apll_pfd_clkout
{
    kSCG_AuxPllPfd0Clk = 0U, /*!< PFD0 output clock selected. */
    kSCG_AuxPllPfd1Clk = 8U, /*!< PFD1 output clock selected. */
    kSCG_AuxPllPfd2Clk = 16U, /*!< PFD2 output clock selected. */
    kSCG_AuxPllPfd3Clk = 24U /*!< PFD3 output clock selected. */
} scg_apll_pfd_clkout_t;

/*!
 * @brief SCG auxiliary PLL configuration.
 */
typedef struct _scg_apll_config
{
    uint8_t enableMode;                  /*!< Enable mode, OR'ed value of _scg_apll_enable_mode */

    scg_async_clk_div_t div1; /*!< APLLDIV1 value.                          */
    scg_async_clk_div_t div2; /*!< APLLDIV2 value.                          */
    scg_async_clk_div_t div3; /*!< APLLDIV3 value.                          */

    scg_apll_src_t src; /*!< Clock source.                            */
    bool isBypassSelected; /*!< LVDS pad (external) clock selected.             */
    bool isPfdSelected; /*!< APLL PFD output clock selected.             */
    uint8_t prediv;     /*!< PLL reference clock divider.             */
    scg_apll_pfd_clkout_t pfdClkout; /*!< SCG auxiliary PLL PFD clouk out select.   */
    uint8_t mult;       /*!< Auxiliary PLL multiplier.                   */
    scg_sys_clk_div_t pllPostdiv1; /*!< Auxiliary PLL Post Clock Divide1 Ratio.     */
    scg_sys_clk_div_t pllPostdiv2; /*!< Auxiliary PLL Post Clock Divide2 Ratio.     */

    uint32_t num : 30; /*!< 30-bit numerator of the Auxiliary PLL Fractional-Loop divider. */
    uint32_t denom : 30; /*!< 30-bit denominator of the Auxiliary PLL Fractional-Loop divider. */
} scg_apll_config_t;
#endif /* FSL_FEATURE_SCG_HAS_APLL */
/* ## End:DefineBack */

/*******************************************************************************
 * API
 ******************************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif

/* ## Start:FuncMisc */
/*!
 * @name MCU System Clock.
 * @{
 */

/*!
 * @brief Gets the SCG system clock frequency.
 *
 * This function gets the SCG system clock frequency. These clocks are used for
 * core, platform, external, and bus clock domains.
 *
 * @param type     Which type of clock to get, core clock or slow clock.
 * @return  Clock frequency.
 */
uint32_t CLOCK_GetSysClkFreq(scg_sys_clk_t type);

/*!
 * @brief Sets the system clock configuration for VLPR mode.
 *
 * This function sets the system clock configuration for VLPR mode.
 *
 * @param config Pointer to the configuration.
 */
static inline void CLOCK_SetVlprModeSysClkConfig(const scg_sys_clk_config_t *config)
{
    assert(config);

    SCG->VCCR = *(const uint32_t *)config;
}

/*!
 * @brief Sets the system clock configuration for RUN mode.
 *
 * This function sets the system clock configuration for RUN mode.
 *
 * @param config Pointer to the configuration.
 */
static inline void CLOCK_SetRunModeSysClkConfig(const scg_sys_clk_config_t *config)
{
    assert(config);

    SCG->RCCR = *(const uint32_t *)config;
}

#if (defined(FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE) && FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE)
/*!
 * @brief Sets the system clock configuration for HSRUN mode.
 *
 * This function sets the system clock configuration for HSRUN mode.
 *
 * @param config Pointer to the configuration.
 */
static inline void CLOCK_SetHsrunModeSysClkConfig(const scg_sys_clk_config_t *config)
{
    assert(config);

    SCG->HCCR = *(const uint32_t *)config;
}
#endif /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */

/*!
 * @brief Gets the system clock configuration in the current power mode.
 *
 * This function gets the system configuration in the current power mode.
 *
 * @param config Pointer to the configuration.
 */
static inline void CLOCK_GetCurSysClkConfig(scg_sys_clk_config_t *config)
{
    assert(config);

    *(uint32_t *)config = SCG->CSR;
}

#if (defined(FSL_FEATURE_SCG_HAS_CLKOUTCNFG) && FSL_FEATURE_SCG_HAS_CLKOUTCNFG)
/*!
 * @brief Sets the clock out selection.
 *
 * This function sets the clock out selection (CLKOUTSEL).
 *
 * @param setting The selection to set.
 * @return  The current clock out selection.
 */
static inline void CLOCK_SetClkOutSel(clock_clkout_src_t setting)
{
    SCG->CLKOUTCNFG = SCG_CLKOUTCNFG_CLKOUTSEL(setting);
}
#endif /* FSL_FEATURE_SCG_HAS_CLKOUTCNFG */
/* @} */

/*!
 * @name SCG System OSC Clock.
 * @{
 */

/*!
 * @brief Initializes the SCG system OSC.
 *
 * This function enables the SCG system OSC clock according to the
 * configuration.
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success System OSC is initialized.
 * @retval kStatus_SCG_Busy System OSC has been enabled and is used by the system clock.
 * @retval kStatus_ReadOnly System OSC control register is locked.
 *
 * @note This function can't detect whether the system OSC has been enabled and
 * used by an IP.
 */
status_t CLOCK_InitSysOsc(const scg_sosc_config_t *config);

/*!
 * @brief De-initializes the SCG system OSC.
 *
 * This function disables the SCG system OSC clock.
 *
 * @retval kStatus_Success System OSC is deinitialized.
 * @retval kStatus_SCG_Busy System OSC is used by the system clock.
 * @retval kStatus_ReadOnly System OSC control register is locked.
 *
 * @note This function can't detect whether the system OSC is used by an IP.
 */
status_t CLOCK_DeinitSysOsc(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetSysOscAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->SOSCDIV;

    switch(asyncClk)
    {
#if (defined(FSL_FEATURE_SCG_HAS_SOSCDIV3) && FSL_FEATURE_SCG_HAS_SOSCDIV3)
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_SOSCDIV_SOSCDIV3_MASK) | SCG_SOSCDIV_SOSCDIV3(divider);
            break;
#endif
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_SOSCDIV_SOSCDIV2_MASK) | SCG_SOSCDIV_SOSCDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_SOSCDIV_SOSCDIV1_MASK) | SCG_SOSCDIV_SOSCDIV1(divider);
            break;
    }

    SCG->SOSCDIV = reg;
}

/*!
 * @brief Gets the SCG system OSC clock frequency (SYSOSC).
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSysOscFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the system OSC.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSysOscAsyncFreq(scg_async_clk_t type);

/*!
 * @brief Checks whether the system OSC clock error occurs.
 *
 * @return  True if the error occurs, false if not.
 */
static inline bool CLOCK_IsSysOscErr(void)
{
    return (bool)(SCG->SOSCCSR & SCG_SOSCCSR_SOSCERR_MASK);
}

/*!
 * @brief Clears the system OSC clock error.
 */
static inline void CLOCK_ClearSysOscErr(void)
{
    SCG->SOSCCSR |= SCG_SOSCCSR_SOSCERR_MASK;
}

/*!
 * @brief Sets the system OSC monitor mode.
 *
 * This function sets the system OSC monitor mode. The mode can be disabled,
 * it can generate an interrupt when the error is disabled, or reset when the error is detected.
 *
 * @param mode Monitor mode to set.
 */
static inline void CLOCK_SetSysOscMonitorMode(scg_sosc_monitor_mode_t mode)
{
    uint32_t reg = SCG->SOSCCSR;

    reg &= ~(SCG_SOSCCSR_SOSCCM_MASK | SCG_SOSCCSR_SOSCCMRE_MASK);

    reg |= (uint32_t)mode;

    SCG->SOSCCSR = reg;
}

/*!
 * @brief Checks whether the system OSC clock is valid.
 *
 * @return  True if clock is valid, false if not.
 */
static inline bool CLOCK_IsSysOscValid(void)
{
    return (bool)(SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK);
}
/* @} */

/*!
 * @name SCG Slow IRC Clock.
 * @{
 */

/*!
 * @brief Initializes the SCG slow IRC clock.
 *
 * This function enables the SCG slow IRC clock according to the
 * configuration.
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success SIRC is initialized.
 * @retval kStatus_SCG_Busy SIRC has been enabled and is used by system clock.
 * @retval kStatus_ReadOnly SIRC control register is locked.
 *
 * @note This function can't detect whether the system OSC has been enabled and
 * used by an IP.
 */
status_t CLOCK_InitSirc(const scg_sirc_config_t *config);

/*!
 * @brief De-initializes the SCG slow IRC.
 *
 * This function disables the SCG slow IRC.
 *
 * @retval kStatus_Success SIRC is deinitialized.
 * @retval kStatus_SCG_Busy SIRC is used by system clock.
 * @retval kStatus_ReadOnly SIRC control register is locked.
 *
 * @note This function can't detect whether the SIRC is used by an IP.
 */
status_t CLOCK_DeinitSirc(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetSircAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->SIRCDIV;

    switch(asyncClk)
    {
#if (defined(FSL_FEATURE_SCG_HAS_SIRCDIV3) && FSL_FEATURE_SCG_HAS_SIRCDIV3)
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_SIRCDIV_SIRCDIV3_MASK) | SCG_SIRCDIV_SIRCDIV3(divider);
            break;
#endif
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_SIRCDIV_SIRCDIV2_MASK) | SCG_SIRCDIV_SIRCDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_SIRCDIV_SIRCDIV1_MASK) | SCG_SIRCDIV_SIRCDIV1(divider);
            break;
    }

    SCG->SIRCDIV = reg;
}

#if (defined(FSL_FEATURE_SCG_HAS_SIRC_LPOPO) && FSL_FEATURE_SCG_HAS_SIRC_LPOPO)
/*!
 * @brief Enables/disables the SCG slow IRC 1khz LPO clock in LLS/VLLSx modes.
 *
 * This function enables/disables the SCG slow IRC 1khz LPO clock in LLS/VLLSx modes.
 *
 * @param enable   Switcher of LPO Power Option which controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes.
 *                 "true" means to enable, "false" means not enabled.
 */
static inline void CLOCK_EnableLpoPowerOption(bool enable)
{
    if (enable)
    {
        SCG->SIRCCSR &= ~SCG_SIRCCSR_LPOPO_MASK;
    }
    else
    {
        SCG->SIRCCSR |= SCG_SIRCCSR_LPOPO_MASK;
    }
}
#endif /* FSL_FEATURE_SCG_HAS_SIRC_LPOPO */

/*!
 * @brief Gets the SCG SIRC clock frequency.
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSircFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the SIRC.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSircAsyncFreq(scg_async_clk_t type);

/*!
 * @brief Checks whether the SIRC clock is valid.
 *
 * @return  True if clock is valid, false if not.
 */
static inline bool CLOCK_IsSircValid(void)
{
    return (bool)(SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK);
}
/* @} */

/*!
 * @name SCG Fast IRC Clock.
 * @{
 */

/*!
 * @brief Initializes the SCG fast IRC clock.
 *
 * This function enables the SCG fast IRC clock according to the configuration.
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success FIRC is initialized.
 * @retval kStatus_SCG_Busy FIRC has been enabled and is used by the system clock.
 * @retval kStatus_ReadOnly FIRC control register is locked.
 *
 * @note This function can't detect whether the FIRC has been enabled and
 * used by an IP.
 */
status_t CLOCK_InitFirc(const scg_firc_config_t *config);

/*!
 * @brief De-initializes the SCG fast IRC.
 *
 * This function disables the SCG fast IRC.
 *
 * @retval kStatus_Success FIRC is deinitialized.
 * @retval kStatus_SCG_Busy FIRC is used by the system clock.
 * @retval kStatus_ReadOnly FIRC control register is locked.
 *
 * @note This function can't detect whether the FIRC is used by an IP.
 */
status_t CLOCK_DeinitFirc(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetFircAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->FIRCDIV;

    switch(asyncClk)
    {
#if (defined(FSL_FEATURE_SCG_HAS_FIRCDIV3) && FSL_FEATURE_SCG_HAS_FIRCDIV3)
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_FIRCDIV_FIRCDIV3_MASK) | SCG_FIRCDIV_FIRCDIV3(divider);
            break;
#endif
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_FIRCDIV_FIRCDIV2_MASK) | SCG_FIRCDIV_FIRCDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_FIRCDIV_FIRCDIV1_MASK) | SCG_FIRCDIV_FIRCDIV1(divider);
            break;
    }

    SCG->FIRCDIV = reg;
}

/*!
 * @brief Gets the SCG FIRC clock frequency.
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetFircFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the FIRC.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetFircAsyncFreq(scg_async_clk_t type);

/*!
 * @brief Checks whether the FIRC clock error occurs.
 *
 * @return  True if the error occurs, false if not.
 */
static inline bool CLOCK_IsFircErr(void)
{
    return (bool)(SCG->FIRCCSR & SCG_FIRCCSR_FIRCERR_MASK);
}

/*!
 * @brief Clears the FIRC clock error.
 */
static inline void CLOCK_ClearFircErr(void)
{
    SCG->FIRCCSR |= SCG_FIRCCSR_FIRCERR_MASK;
}

/*!
 * @brief Checks whether the FIRC clock is valid.
 *
 * @return  True if clock is valid, false if not.
 */
static inline bool CLOCK_IsFircValid(void)
{
    return (bool)(SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK);
}
/* @} */

#if (defined(FSL_FEATURE_SCG_HAS_ROSC) && FSL_FEATURE_SCG_HAS_ROSC)
/*!
 * @brief Gets the SCG RTC OSC clock frequency.
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetRtcOscFreq(void);

/*!
 * @brief Checks whether the RTC OSC clock error occurs.
 *
 * @return  True if error occurs, false if not.
 */
static inline bool CLOCK_IsRtcOscErr(void)
{
    return (bool)(SCG->ROSCCSR & SCG_ROSCCSR_ROSCERR_MASK);
}

/*!
 * @brief Clears the RTC OSC clock error.
 */
static inline void CLOCK_ClearRtcOscErr(void)
{
    SCG->ROSCCSR |= SCG_ROSCCSR_ROSCERR_MASK;
}

/*!
 * @brief Sets the RTC OSC monitor mode.
 *
 * This function sets the RTC OSC monitor mode. The mode can be disabled.
 * It can generate an interrupt when the error is disabled, or reset when the error is detected.
 *
 * @param mode Monitor mode to set.
 */
static inline void CLOCK_SetRtcOscMonitorMode(scg_rosc_monitor_mode_t mode)
{
    uint32_t reg = SCG->ROSCCSR;

    reg &= ~(SCG_ROSCCSR_ROSCCM_MASK | SCG_ROSCCSR_ROSCCMRE_MASK);

    reg |= (uint32_t)mode;

    SCG->ROSCCSR = reg;
}

/*!
 * @brief Checks whether the RTC OSC clock is valid.
 *
 * @return  True if the clock is valid, false if not.
 */
static inline bool CLOCK_IsRtcOscValid(void)
{
    return (bool)(SCG->ROSCCSR & SCG_ROSCCSR_ROSCVLD_MASK);
}
/* @} */
#endif /* FSL_FEATURE_SCG_HAS_ROSC */

#if (defined(FSL_FEATURE_SCG_HAS_APLL) && FSL_FEATURE_SCG_HAS_APLL)
/* @} */
/*!
 * @brief Initializes the SCG auxiliary PLL.
 *
 * This function enables the SCG auxiliary PLL clock according to the
 * configuration. The auxiliary PLL can use the system OSC or FIRC as
 * the clock source. Ensure that the source clock is valid before
 * calling this function.
 *
 * Example code for initializing APLL clock output:
 * @code
 * const scg_apll_config_t g_scgAuxPllConfig = {.enableMode = kSCG_AuxPllEnable,
 *                                            .div1 = kSCG_AsyncClkDisable,
 *                                            .div2 = kSCG_AsyncClkDisable,
 *                                            .div3 = kSCG_AsyncClkDisable,
 *                                            .src = kSCG_SysPllSrcFirc,
 *                                            .isBypassSelected = false,
 *                                            .isPfdSelected = false, // Configure APLL PFD as diabled
 *                                            .prediv = 5U,
 *                                            .pfdClkout = kSCG_AuxPllPfd0Clk, // No need to configure pfdClkout; only needed for initialization
 *                                            .mult = 20U,
 *                                            .pllPostdiv1 = kSCG_SysClkDivBy3,
 *                                            .pllPostdiv2 = kSCG_SysClkDivBy4,
 *                                            .num = 578,
 *                                            .denom = 1000};
 * CLOCK_InitAuxPll(&g_scgAuxPllConfig);
 * @endcode
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success auxiliary PLL is initialized.
 * @retval kStatus_SCG_Busy auxiliary PLL has been enabled and is used by the system clock.
 * @retval kStatus_ReadOnly auxiliary PLL control register is locked.
 *
 * @note This function can't detect whether the auxiliary PLL has been enabled and
 * is used by an IP.
 */
status_t CLOCK_InitAuxPll(const scg_apll_config_t *config);

/*!
 * @brief De-initializes the SCG auxiliary PLL.
 *
 * This function disables the SCG auxiliary PLL.
 *
 * @retval kStatus_Success auxiliary PLL is deinitialized.
 * @retval kStatus_SCG_Busy auxiliary PLL is used by the system clock.
 * @retval kStatus_ReadOnly auxiliary PLL control register is locked.
 *
 * @note This function can't detect whether the auxiliary PLL is used by an IP.
 */
status_t CLOCK_DeinitAuxPll(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetAuxPllAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->APLLDIV;

    switch(asyncClk)
    {
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_APLLDIV_APLLDIV3_MASK) | SCG_APLLDIV_APLLDIV3(divider);
            break;
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_APLLDIV_APLLDIV2_MASK) | SCG_APLLDIV_APLLDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_APLLDIV_APLLDIV1_MASK) | SCG_APLLDIV_APLLDIV1(divider);
            break;
    }

    SCG->APLLDIV = reg;
}

/*!
 * @brief Gets the SCG auxiliary PLL clock frequency.
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetAuxPllFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the auxiliary PLL.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetAuxPllAsyncFreq(scg_async_clk_t type);

/*!
 * @brief Gets the SCG auxiliary PLL PFD clock frequency.
 *
 * @param pfdClkout     The selected PFD clocks out. See "scg_apll_pfd_clkout_t".
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetAuxPllPfdFreq(scg_apll_pfd_clkout_t pfdClkout);

/*!
 * @brief Enables the SCG auxiliary PLL Fractional Divide (PFD) clock out with configurations.
 *
 * APLL Frequency = Fref * (MULT + NUM/DENOM)
 * PFD Clock Frequency = PLL output frequency * 18/frac value
 *
 * Example code for configuring APLL as APLL PFD clock output:
 * @code
 * const scg_apll_config_t g_scgAuxPllConfig = {.enableMode = kSCG_AuxPllEnable,
 *                                            .div1 = kSCG_AsyncClkDisable,
 *                                            .div2 = kSCG_AsyncClkDisable,
 *                                            .div3 = kSCG_AsyncClkDisable,
 *                                            .src = kSCG_SysPllSrcFirc,
 *                                            .isBypassSelected = false,
 *                                            .isPfdSelected = true, // Configure APLL PFD as enabled
 *                                            .prediv = 5U,
 *                                            .pfdClkout = kSCG_AuxPllPfd3Clk, // Configure APLL PFD3 as the output clock
 *                                            .mult = 20U,
 *                                            .pllPostdiv1 = kSCG_SysClkDivBy1,
 *                                            .pllPostdiv2 = kSCG_SysClkDivBy1,
 *                                            .num = 578,
 *                                            .denom = 1000};
 * CLOCK_InitAuxPll(&g_scgAuxPllConfig);
 * CLOCK_EnableAuxPllPfdClkout(g_scgAuxPllConfig.pfdClkout, 15U);
 * @endcode
 *
 * @param pfdClkout  APLL PFD clock out select.
 * @param fracValue  Fractional Divider value. Recommended to be kept between 12-35 for all PFDs.
 */
void CLOCK_EnableAuxPllPfdClkout(scg_apll_pfd_clkout_t pfdClkout, uint8_t fracValue);

/*!
 * @brief Disables the SCG auxiliary PLL Fractional Divide (PFD) clock out.
 */
static inline void CLOCK_DisableAuxPllPfdClkout(scg_apll_pfd_clkout_t pfdClkout)
{
    SCG->APLLPFD |= SCG_PLLPFD_PFD_CLKGATE_MASK(pfdClkout);
}

/*!
 * @brief Enables the SCG auxiliary PLL spread spectrum modulation feature with configurations.
 *
 * This function sets the SCG auxiliary PLL spread spectrum modulation configurations.
 * STOP and STEP together control the modulation depth (maximum frequency change)
 * and modulation frequency.
 *
 * Modulation Depth = (STOP/MFD)*Fref where MFD is the DENOM field value in DENOM register.
 * Modulation Frequency = (STEP/(2*STOP))*Fref.
 *
 * @param step  APLL Spread Spectrum STEP.
 * @param stop  APLL Spread Spectrum STOP.
 */
static inline void CLOCK_EnableAuxPllSpectrumModulation(uint16_t step, uint16_t stop)
{
    SCG->APLLSS = (SCG->APLLSS & ~(SCG_APLLSS_STEP_MASK | SCG_APLLSS_STOP_MASK))
    | (SCG_APLLSS_STEP(step) | SCG_APLLSS_STOP(stop) | SCG_APLLSS_ENABLE_MASK);
}

/*!
 * @brief Disables the SCG auxiliary PLL spread spectrum modulation.
 *
 */
static inline void CLOCK_DisableAuxPllSpectrumModulation(void)
{
    SCG->APLLSS &= ~SCG_APLLSS_ENABLE_MASK;
}

/*!
 * @brief Sets the SCG auxiliary PLL lock time.
 *
 * @param lockTime  Reference clocks to count before APLL is considered locked and valid.
 */
static inline void CLOCK_SetAuxPllLockTime(uint16_t lockTime)
{
    SCG->APLLLOCK_CNFG = SCG_APLLLOCK_CNFG_LOCK_TIME(lockTime);
}

/*!
 * @brief Checks whether the auxiliary PLL clock is valid.
 *
 * @return  True if the clock is valid, false if not.
 */
static inline bool CLOCK_IsAuxPllValid(void)
{
    return (bool)(SCG->APLLCSR & SCG_APLLCSR_APLLVLD_MASK);
}
/* @} */
#endif /* FSL_FEATURE_SCG_HAS_APLL */

#if (defined(FSL_FEATURE_SCG_HAS_SPLL) && FSL_FEATURE_SCG_HAS_SPLL)
#if (!(defined(FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1) && FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1))
/*!
 * @name SCG System PLL Clock.
 * @{
 */

/*!
 * @brief Calculates the MULT and PREDIV for the PLL.
 *
 * This function calculates the proper MULT and PREDIV to generate the desired PLL
 * output frequency with the input reference clock frequency. It returns the closest
 * frequency match that the PLL can generate. The corresponding MULT/PREDIV are returned with
 * parameters. If the desired frequency is not valid, this function returns 0.
 *
 * @param refFreq     The input reference clock frequency.
 * @param desireFreq  The desired output clock frequency.
 * @param mult        The value of MULT.
 * @param prediv      The value of PREDIV.
 * @return The PLL output frequency with the MULT and PREDIV; If
 * the desired frequency can't be generated, this function returns 0U.
 */
uint32_t CLOCK_GetSysPllMultDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *mult, uint8_t *prediv);
#endif /* FSL_FEATURE_SCG_HAS_SPLLPOSTDIV1 */

/*!
 * @brief Initializes the SCG system PLL.
 *
 * This function enables the SCG system PLL clock according to the
 * configuration. The system PLL can use the system OSC or FIRC as
 * the clock source. Ensure that the source clock is valid before
 * calling this function.
 *
 * Example code for initializing SPLL clock output:
 * @code
 * const scg_spll_config_t g_scgSysPllConfig = {.enableMode = kSCG_SysPllEnable,
 *                                            .monitorMode = kSCG_SysPllMonitorDisable,
 *                                            .div1 = kSCG_AsyncClkDivBy1,
 *                                            .div2 = kSCG_AsyncClkDisable,
 *                                            .div3 = kSCG_AsyncClkDivBy2,
 *                                            .src = kSCG_SysPllSrcFirc,
 *                                            .isBypassSelected = false,
 *                                            .isPfdSelected = false, // Configure SPLL PFD as diabled
 *                                            .prediv = 5U,
 *                                            .pfdClkout = kSCG_AuxPllPfd0Clk, // No need to configure pfdClkout; only needed for initialization
 *                                            .mult = 20U,
 *                                            .pllPostdiv1 = kSCG_SysClkDivBy3,
 *                                            .pllPostdiv2 = kSCG_SysClkDivBy4};
 * CLOCK_InitSysPll(&g_scgSysPllConfig);
 * @endcode
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success System PLL is initialized.
 * @retval kStatus_SCG_Busy System PLL has been enabled and is used by the system clock.
 * @retval kStatus_ReadOnly System PLL control register is locked.
 *
 * @note This function can't detect whether the system PLL has been enabled and
 * used by an IP.
 */
status_t CLOCK_InitSysPll(const scg_spll_config_t *config);

/*!
 * @brief De-initializes the SCG system PLL.
 *
 * This function disables the SCG system PLL.
 *
 * @retval kStatus_Success system PLL is deinitialized.
 * @retval kStatus_SCG_Busy system PLL is used by the system clock.
 * @retval kStatus_ReadOnly System PLL control register is locked.
 *
 * @note This function can't detect whether the system PLL is used by an IP.
 */
status_t CLOCK_DeinitSysPll(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetSysPllAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->SPLLDIV;

    switch(asyncClk)
    {
#if (defined(FSL_FEATURE_SCG_HAS_SPLLDIV3) && FSL_FEATURE_SCG_HAS_SPLLDIV3)
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_SPLLDIV_SPLLDIV3_MASK) | SCG_SPLLDIV_SPLLDIV3(divider);
            break;
#endif
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_SPLLDIV_SPLLDIV2_MASK) | SCG_SPLLDIV_SPLLDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_SPLLDIV_SPLLDIV1_MASK) | SCG_SPLLDIV_SPLLDIV1(divider);
            break;
    }

    SCG->SPLLDIV = reg;
}

/*!
 * @brief Gets the SCG system PLL clock frequency.
 *
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSysPllFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the system PLL.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSysPllAsyncFreq(scg_async_clk_t type);

#if (defined(FSL_FEATURE_SCG_HAS_SPLLPFD) && FSL_FEATURE_SCG_HAS_SPLLPFD)
/*!
 * @brief Gets the SCG system PLL PFD clock frequency.
 *
 * @param pfdClkout     The selected PFD clock out. See "scg_spll_pfd_clkout_t".
 * @return  Clock frequency; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetSysPllPfdFreq(scg_spll_pfd_clkout_t pfdClkout);

/*!
 * @brief Enables the SCG system PLL Fractional Divide (PFD) clock out with configurations.
 *
 * SPLL Frequency = Fref * (MULT + NUM/DENOM)
 * PFD Clock Frequency = PLL output frequency * 18/frac value
 *
 * @code
 * Example code for configuring SPLL as SPLL PFD clock output:
 * const scg_spll_config_t g_scgSysPllConfig = {.enableMode = kSCG_SysPllEnable,
 *                                            .div1 = kSCG_AsyncClkDisable,
 *                                            .div2 = kSCG_AsyncClkDisable,
 *                                            .div3 = kSCG_AsyncClkDisable,
 *                                            .src = kSCG_SysPllSrcFirc,
 *                                            .isBypassSelected = false,
 *                                            .isPfdSelected = true, // Configure SPLL PFD as enabled
 *                                            .prediv = 5U,
 *                                            .pfdClkout = kSCG_AuxPllPfd3Clk, // Selects the SPLL PFD3 as the output clock
 *                                            .mult = 20U,
 *                                            .pllPostdiv1 = kSCG_SysClkDivBy1,
 *                                            .pllPostdiv2 = kSCG_SysClkDivBy1};
 * CLOCK_InitSysPll(&g_scgSysPllConfig);
 * CLOCK_EnableSysPllPfdClkout(g_scgSysPllConfig.pfdClkout, 15U);
 * @endcode
 *
 * @param pfdClkout  SPLL PFD clock out select.
 * @param fracValue  Fractional Divider value. Recommended to be kept between 12-35 for all PFDs.
 */
void CLOCK_EnableSysPllPfdClkout(scg_spll_pfd_clkout_t pfdClkout, uint8_t fracValue);

/*!
 * @brief Disables the SCG system PLL Fractional Divide (PFD) clock out.
 */
static inline void CLOCK_DisableSysPllPfdClkout(scg_spll_pfd_clkout_t pfdClkout)
{
    SCG->SPLLPFD |= SCG_PLLPFD_PFD_CLKGATE_MASK(pfdClkout);
}
#endif /* FSL_FEATURE_SCG_HAS_SPLLPFD */

/*!
 * @brief Checks whether the system PLL clock error occurs.
 *
 * @return  True if an error occurs, false if not.
 */
static inline bool CLOCK_IsSysPllErr(void)
{
    return (bool)(SCG->SPLLCSR & SCG_SPLLCSR_SPLLERR_MASK);
}

/*!
 * @brief Clears the system PLL clock error.
 */
static inline void CLOCK_ClearSysPllErr(void)
{
    SCG->SPLLCSR |= SCG_SPLLCSR_SPLLERR_MASK;
}

#if (defined(FSL_FEATURE_SCG_HAS_SPLL_MONITOR) && FSL_FEATURE_SCG_HAS_SPLL_MONITOR)
/*!
 * @brief Sets the system PLL monitor mode.
 *
 * This function sets the system PLL monitor mode. The mode can be disabled.
 * It can generate an interrupt when the error is disabled, or reset when the error is detected.
 *
 * @param mode Monitor mode to set.
 */
static inline void CLOCK_SetSysPllMonitorMode(scg_spll_monitor_mode_t mode)
{
    uint32_t reg = SCG->SPLLCSR;

    reg &= ~(SCG_SPLLCSR_SPLLCM_MASK | SCG_SPLLCSR_SPLLCMRE_MASK);

    reg |= (uint32_t)mode;

    SCG->SPLLCSR = reg;
}
#endif /* FSL_FEATURE_SCG_HAS_SPLL_MONITOR */

/*!
 * @brief Checks whether the system PLL clock is valid.
 *
 * @return  True if the clock is valid, false if not.
 */
static inline bool CLOCK_IsSysPllValid(void)
{
    return (bool)(SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK);
}
/* @} */
#endif /* FSL_FEATURE_SCG_HAS_SPLL */

#if (defined(FSL_FEATURE_SCG_HAS_LPFLL) && FSL_FEATURE_SCG_HAS_LPFLL)
/*!
 * @name SCG Low Power FLL Clock.
 * @{
 */
/*!
 * @brief Initializes the SCG LPFLL clock.
 *
 * This function enables the SCG LPFLL clock according to the configuration.
 *
 * @param config   Pointer to the configuration structure.
 * @retval kStatus_Success LPFLL is initialized.
 * @retval kStatus_SCG_Busy LPFLL has been enabled and is used by the system clock.
 * @retval kStatus_ReadOnly LPFLL control register is locked.
 *
 * @note This function can't detect whether the LPFLL has been enabled and
 * used by an IP.
 */
status_t CLOCK_InitLpFll(const scg_lpfll_config_t *config);

/*!
 * @brief De-initializes the SCG LPFLL.
 *
 * This function disables the SCG LPFLL.
 *
 * @retval kStatus_Success LPFLL is deinitialized.
 * @retval kStatus_SCG_Busy LPFLL is used by the system clock.
 * @retval kStatus_ReadOnly LPFLL control register is locked.
 *
 * @note This function can't detect whether the LPFLL is used by an IP.
 */
status_t CLOCK_DeinitLpFll(void);

/*!
 * @brief Set the asynchronous clock divider.
 *
 * @param asyncClk Which asynchronous clock to configure.
 * @param divider The divider value to set.
 *
 * @note There might be glitch when changing the asynchronous divider, so make sure
 * the asynchronous clock is not used while changing divider.
 */
static inline void CLOCK_SetLpFllAsyncClkDiv(scg_async_clk_t asyncClk, scg_async_clk_div_t divider)
{
    uint32_t reg = SCG->LPFLLDIV;

    switch(asyncClk)
    {
#if (defined(FSL_FEATURE_SCG_HAS_LPFLLDIV3) && FSL_FEATURE_SCG_HAS_LPFLLDIV3)
        case kSCG_AsyncDiv3Clk:
            reg = (reg & ~SCG_LPFLLDIV_LPFLLDIV3_MASK) | SCG_LPFLLDIV_LPFLLDIV3(divider);
            break;
#endif
        case kSCG_AsyncDiv2Clk:
            reg = (reg & ~SCG_LPFLLDIV_LPFLLDIV2_MASK) | SCG_LPFLLDIV_LPFLLDIV2(divider);
            break;
        default:
            reg = (reg & ~SCG_LPFLLDIV_LPFLLDIV1_MASK) | SCG_LPFLLDIV_LPFLLDIV1(divider);
            break;
    }

    SCG->LPFLLDIV = reg;
}

/*!
 * @brief Gets the SCG LPFLL clock frequency.
 *
 * @return  Clock frequency in Hz; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetLpFllFreq(void);

/*!
 * @brief Gets the SCG asynchronous clock frequency from the LPFLL.
 *
 * @param type     The asynchronous clock type.
 * @return  Clock frequency in Hz; If the clock is invalid, returns 0.
 */
uint32_t CLOCK_GetLpFllAsyncFreq(scg_async_clk_t type);

/*!
 * @brief Checks whether the LPFLL clock is valid.
 *
 * @return  True if the clock is valid, false if not.
 */
static inline bool CLOCK_IsLpFllValid(void)
{
    return (bool)(SCG->LPFLLCSR & SCG_LPFLLCSR_LPFLLVLD_MASK);
}
/* @} */
#endif /* FSL_FEATURE_SCG_HAS_LPFLL */

#if (defined(FSL_FEATURE_SOC_OSC32_COUNT) && FSL_FEATURE_SOC_OSC32_COUNT)
/*!
 * @name OSC32 operations
 * @{
 */
/*!
 * @brief Initializes OSC32.
 *
 * @param base OSC32 peripheral base address.
 * @param mode OSC32 work mode, see @ref osc32_mode_t
 */
void OSC32_Init(OSC32_Type *base, osc32_mode_t mode);

/*!
 * @brief Deinitializes OSC32.
 *
 * @param base OSC32 peripheral base address.
 */
void OSC32_Deinit(OSC32_Type *base);
/* @} */
#endif /* FSL_FEATURE_SOC_OSC32_COUNT */

/*!
 * @name External clock frequency
 * @{
 */

/*!
 * @brief Sets the XTAL0 frequency based on board settings.
 *
 * @param freq The XTAL0/EXTAL0 input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal0Freq(uint32_t freq)
{
    g_xtal0Freq = freq;
}

#if (!(defined(FSL_FEATURE_SOC_NO_XTAL32_RTCCLKIN) && FSL_FEATURE_SOC_NO_XTAL32_RTCCLKIN))
/*!
 * @brief Sets the XTAL32 frequency based on board settings.
 *
 * @param freq The XTAL32/EXTAL32 input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal32Freq(uint32_t freq)
{
    g_xtal32Freq = freq;
}
#endif

#if (defined(FSL_FEATURE_SOC_HAS_LVDS) && FSL_FEATURE_SOC_HAS_LVDS)
/*!
 * @brief Sets the LVDS pad frequency based on board settings.
 *
 * @param freq The LVDS pad input clock frequency in Hz.
 */
static inline void CLOCK_SetLvdsFreq(uint32_t freq)
{
    g_lvdsFreq = freq;
}
#endif /* FSL_FEATURE_SOC_HAS_LVDS */
/* @} */
/* ## End:FuncMisc */

#if defined(__cplusplus)
}
#endif

/*!
 * @}
 */

#endif /* FSL_SCG_H */
